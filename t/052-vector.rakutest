#!/usr/bin/env perl6

use Test;
use lib 'lib';
use Math::Libgsl::Vector;
use Math::Libgsl::Constants;

subtest {
  my Math::Libgsl::Vector $v1 .= new(:size(10));
  isa-ok $v1, Math::Libgsl::Vector, 'new using pair';
  ok $v1.vector.size == 10, 'attributes ok';
  my Math::Libgsl::Vector $v2 .= new(10);
  isa-ok $v2, Math::Libgsl::Vector, 'new using single value';
}, 'vector allocation';

subtest {
  my Math::Libgsl::Vector $v1 .= new(:size(10));
  ok $v1.get(0) == 0, 'get element';
  ok $v1[0] == 0, 'get element using postcircumfix';
  lives-ok { $v1.set(0, 10) }, 'element set lives';
  ok $v1.get(0) == 10e0, 'element set';
  lives-ok { $v1[1] = 12 }, 'set element using postcircumfix lives';
  ok $v1.get(1) == 12e0, 'element set using postcircumfix lives';
  is-deeply $v1[^3], (10e0, 12e0, 0e0), 'get range of elements';
  lives-ok { $v1.setall(1) }, 'set all elements';
  is-deeply $v1[^10], (1e0 xx 10), 'all elements set';
  lives-ok { $v1.zero }, 'set all elements to zero';
  is-deeply $v1[^10], (0e0 xx 10), 'all elements zeroed';
  lives-ok { $v1.basis(1) }, 'basis ok';
  is-deeply $v1[^10], (0e0, 1e0, 0e0 xx 8).flat, 'basis vector';
}, 'vector set & get';

subtest {
  my Math::Libgsl::Vector $v1 .= new(:size(10));
  $v1.setall(1);
  my $filename = 't/vector.dat';
  LEAVE { with $filename.IO { .unlink if .e } }
  ok $v1.write($filename) == GSL_SUCCESS, 'can write a vector to file';
  ok $v1.read($filename) == GSL_SUCCESS, 'can read a vector from file';
  ok $v1.printf($filename, "%3.1lf") == GSL_SUCCESS, 'can print a vector to file';
  is-deeply $filename.IO.lines, '1.0' xx 10, 'vector file ok';
}, 'vector IO';

subtest {
  my Math::Libgsl::Vector $v1 .= new(:size(10));
  $v1.setall(1);
  my Math::Libgsl::Vector $vv1;
  lives-ok { $vv1 = $v1.subvector(0, 3) }, 'create subvector';
  $vv1.setall(12);
  is-deeply $v1[^10], (12e0 xx 3, 1e0 xx 7).flat, 'modify vector using subvector';
  $v1.setall(1);
  my Math::Libgsl::Vector $vv2;
  lives-ok { $vv2 = $v1.subvector-stride(0, 2, 3) }, 'create subvector with stride';
  $vv2.setall(12);
  is-deeply $v1[^10], ((12e0, 1e0) xx 3, 1e0 xx 4).flat, 'modify vector using subvector with stride';
  my @a = 1 xx 10;
  my Math::Libgsl::Vector $vv3;
  lives-ok { $vv3 = view-array @a }, 'create array using vector view';
  is-deeply $vv3[^10], (1e0 xx 10).flat, 'verify array using vector view';
  my Math::Libgsl::Vector $vv4;
  lives-ok { $vv4 = view-array-stride @a, 2 }, 'create array with stride using vector view';
  is-deeply $vv4[^5], (1e0 xx 5).flat, 'verify array with stride using vector view';
  my Math::Libgsl::Vector::Complex64 $cv .= new(:size(10));
  isa-ok $cv, Math::Libgsl::Vector::Complex64, 'new complex vector';
  lives-ok { $cv.setall(1+2i) }, 'set all elements to complex values';
  is-deeply $cv[^10], (1+2i xx 10), 'all complex elements set';
  my Math::Libgsl::Vector $vv5;
  lives-ok { $vv5 = $cv.complex64-real }, 'create real view from complex vector';
  is-deeply $vv5[^10], (1e0 xx 10).flat, 'verify real view';
  my Math::Libgsl::Vector $vv6;
  lives-ok { $vv6 = $cv.complex64-imag }, 'create imag view from complex vector';
  is-deeply $vv6[^10], (2e0 xx 10).flat, 'verify imag view';
}, 'views';

subtest {
  my Math::Libgsl::Vector $v1 .= new(:size(10));
  $v1.set($_, $_.Num) for ^10;
  my Math::Libgsl::Vector $v2 .= new(:size(10));
  lives-ok { $v2.copy($v1) }, 'can copy';
  is-deeply $v2[^10], (0..9).flat».Num, 'copy ok';
  $v2.zero;
  lives-ok { $v1.swap($v2) }, 'can swap';
  is-deeply $v1[^10], (0e0 xx 10), 'swap ok';
}, 'vector copy';

subtest {
  my Math::Libgsl::Vector $v1 .= new(:size(10));
  $v1.set($_, $_.Num) for ^10;
  lives-ok { $v1.swap-elems(0, 1) }, 'can exchange elements';
  is-deeply $v1[^10], (1e0, 0e0, 2e0..9e0).flat, 'swap elements ok';
  $v1.set($_, $_.Num) for ^10;
  lives-ok { $v1.reverse }, 'can reverse elements';
  is-deeply $v1[^10], (9e0…0e0).flat, 'reverse elements ok';
}, 'element exchange';

subtest {
  my Math::Libgsl::Vector $v1 .= new(:size(10));
  $v1.setall(4);
  my Math::Libgsl::Vector $v2 .= new(:size(10));
  $v2.setall(2);
  lives-ok { $v1.add($v2) }, 'can add';
  is-deeply $v1[^10], (6e0 xx 10), 'add ok';
  lives-ok { $v1.sub($v2) }, 'can sub';
  is-deeply $v1[^10], (4e0 xx 10), 'sub ok';
  lives-ok { $v1.mul($v2) }, 'can mul';
  is-deeply $v1[^10], (8e0 xx 10), 'mul ok';
  lives-ok { $v1.div($v2) }, 'can div';
  is-deeply $v1[^10], (4e0 xx 10), 'div ok';
}, 'vector operations';

subtest {
  my Math::Libgsl::Vector $v1 .= new(:size(10));
  $v1.set($_, $_.Num) for ^10;
  ok $v1.max == 9e0, 'max element';
  ok $v1.min == 0e0, 'min element';
  is-deeply $v1.minmax, (0e0, 9e0), 'min & max elements';
  ok $v1.max-index == 9, 'index of max element';
  ok $v1.min-index == 0, 'index of min element';
  is-deeply $v1.minmax-index, (0, 9), 'index of min & max elements';
}, 'vector min & max';

subtest {
  my Math::Libgsl::Vector $v1 .= new(:size(10));
  ok $v1.is-null, 'all elements of v are 0';
  $v1.setall(2e0);
  ok $v1.is-pos, 'all elements of v are >0';
  $v1.set(0, 0e0);
  nok $v1.is-pos, 'fails if not all elements of v are >0';
  $v1.setall(-2e0);
  ok $v1.is-neg, 'all elements of v are <0';
  my Math::Libgsl::Vector $v2 .= new(:size(10));
  $v2.setall(-2e0);
  ok $v1.is-equal($v2), 'two vectors are equal';
}, 'vector properties';

done-testing;
